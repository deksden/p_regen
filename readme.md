## P Regen

Консольная утилита для регенерации кода проекта на основании декларации с сервера. 

Приложение обращается к серверу, генерирует сниппеты через подсистему codegen. Сниппеты 
сохраняются в файловую базу. Каждый сниппеты имеет конфигурацию в JSON файле. 

### Алгоритм работы утилиты 

Обрабатываем аргументы. 

Если справка / версия - выводим их. 
Если новый модуль - делаем новый модуль. Для этого получаем шаблон с сервера и инициализируем начальные значения 
фрагментов.

Иначе начинаем главный процесс. 

Грузим конфигурацию. Обрабатывать в конфигурации будем блок фрагментов. 

Для каждого фрагмента в цикле: загружаем его описание - api path для получения текущего кода 
с сервера. Папку где храним текущие версии фрагментов. Ссылку на файл с кодом. Идентификатор 
фрагмента. 

Загружаем файл с кодом. Находим фрагмент. Создаем в памяти образ фрагмента. Берем текущий фрагмент в базе, загружаем в память. Сравниваем фрагменты в коде и базе. Если не совпадают - то не обрабатываем файл.

Если фрагменты совпадают - можно спрашивать обновление. Делаем запрос на сервер с текущим статусом фрагмента. Если текущий отличается от базы - то будем обновлять. Сделаем новый идентификатор и сохраним его. Сохраним фрагмент в базу. Заменим фрагмент в коде и сохраним файл. 

Проект обработан. 

Итого - блоки функциональности: 
* Парсинг аргументов (+)
* Вывод версии (+)
* Вывод справки (+)
* Обработка фрагмента 
* Тестировать совпадение фрагментов
* Получить фрагмент из файла
* заменить фрагмент в файле

## Формат конфигурации

Файл конфигурации по-умолчанию называется `.p-regenrc`. Имеет формат JSON объекта со следующими свойствами:

* свойство `server`: объект со следующими полями:
  * `url`: строка, указывающая на сервер, к которому будем подключаться за данными;
  * `auth`: (="JWT) тип авторизации; сейчас поддерживаем только "JWT";
  * `authPath`: (="/auth/login") путь на сервере, по которому делаем авторизацию;
  * `email`: логин для авторизации
  * `password`: пароль для авторизации
* свойство `files`: массив объектов со следующими свойствами:
  * свойство `name`: имя файла;
  * свойство `fragments`: массив объектов со следующими свойствами:
    * `id`: идентификатор фрагмента; по нему ищем кэшированный образ фрагмента; должно быть уникальным в
    пределах файла; 
    * `path`: путь на сервере к данным этого фрагмента;
* свойство `basePath`: путь к папке локальных файлов для обработки;
* свойство `cachePath`: путь к папке кэша фрагментов;
* свойство `models`: массив имен моделей, с которым будем работать в проекте;
  * свойство list: описывает специфические опции генерации списка;
  * свойство edit: описывает специфические свойства генерации формы редактирования;
  * свойство create: специфические свойства генерации формы для создания объекта; 

## TODO:

 * добавить валидатор для файла конфигурации (ajv?)
 * как определить список моделей для генерации файлов? Если не нужно весь список имеющихся на сервере моделей 
добавлять в генерацию; свойство `models`? 

Общая схема работы: 
* создаем новую модель на сервере
* вызываем генерацию новых файлов для модели на клиенте, параметр `--new`:
  * код файл ресурса, по пути из `codegen/model/:modelName`, размещаем в `basePath/src/resources`
  * генерируем новый код для всех стандартных фрагментов файла ресурсов;
  * регенерируем сниппет app-js-model-imports (перечень моделей с автоматической генерацией)
  * в файл конфигурации дописываем новую models

Стандартные фрагменты:
  * app-model-${kebabCase(modelName)}-filter-fields